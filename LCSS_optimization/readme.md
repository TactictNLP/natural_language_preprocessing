1. longest common subsequence  
    最长公共子序列算法 是对有序队列 计算相似度时的常用算法，如轨迹相似度，文本相似度。  
    原始的基于动态规划的方法，可能存在 对换两个sequence的顺序时，计算的公共子序列不同；  
    而对于一些场景，又要求子序列的任意点不能是孤立的，尤其在NLP领域，孤立字很难体现现实含义；  
    基于以上两点，对LCSS进行了改进。  
    
2. 实验效果  
原字符串 ：s1:  abbca      s2:  baca   
 
对换s1 s2先后顺序，可获得不同的 公共子序列 ：  
aca  
 [0, 3, 4]   # 在s1中的位置    
 [1, 2, 3]   # 在s2中的位置   
bca   
 [2, 3, 4]  # 在s1中的位置   
 [0, 2, 3]  # 在s2中的位置   
 
1） 参数设置： 
keep_continue=True  # 仅保留连续点，剔除孤立点  
mode='any'  #  判断点连续的方法， any表示该点在任意一个序列中有相邻的公共点即可，  both表示 该点在两个序列中都要存在相邻的公共点才行  

通过公共子序列在两个字符串中的位置，我们选择连续性更强的子串：  
 bca 
 [2, 3, 4] 
 [0, 2, 3]


2）参数设置：
keep_continue=True  # 仅保留连续点，剔除孤立点  
mode='both'  #  判断点连续的方法， both表示 该点在两个序列中都要存在相邻的公共点才行  

仅保留 在两个序列中都存在相邻公共点的公共点 ：  
 ca   
 [3, 4]   
 [2, 3]  
(首字母  a 和 b 都被判定为孤立点)  

